# Архитектурные решения проекта

Документ описывает ключевые архитектурные решения, принятые при разработке приложения для ремонтной службы.

## 1. Модульная архитектура

**Решение**: Использована модульная структура с разделением на модули (Auth, User, Request).

**Обоснование**: 
- Улучшает организацию кода и его поддерживаемость
- Позволяет легко добавлять новые модули
- Упрощает тестирование и рефакторинг
- Соответствует принципам SOLID

**Реализация**: Каждый модуль содержит свои модели, репозитории, сервисы, контроллеры и маршруты. Модули регистрируются через `ModuleServiceProvider`.

## 2. Разделение на слои: Repository → Service → Controller

**Решение**: Использована трёхслойная архитектура:
- **Repository** - работа с базой данных
- **Service** - бизнес-логика
- **Controller** - обработка HTTP-запросов

**Обоснование**:
- Разделение ответственности (SRP)
- Упрощение тестирования (можно мокировать репозитории)
- Возможность переиспользования бизнес-логики
- Упрощение миграции на другую БД

**Реализация**: 
- `RequestRepository` - методы работы с БД
- `RequestService` - бизнес-логика (создание, назначение, взятие в работу)
- Контроллеры используют сервисы, сервисы используют репозитории

## 3. Защита от race condition через транзакции и блокировки

**Решение**: При взятии заявки в работу используется `DB::transaction()` с `lockForUpdate()` для блокировки строки.

**Обоснование**:
- Предотвращает параллельное изменение статуса заявки
- Гарантирует целостность данных
- Один запрос успешен, второй получает понятную ошибку

**Реализация**: 
```php
DB::transaction(function () use ($request, $master) {
    $lockedRequest = Request::lockForUpdate()->find($request->id);
    // Проверка статуса и обновление
});
```

**Альтернативы**: 
- Оптимистичная блокировка (версионирование) - сложнее реализация
- Очереди - избыточно для данного случая

## 4. Enum для статусов заявок

**Решение**: Статусы заявок определены как константы класса `Request` с enum в БД.

**Обоснование**:
- Типобезопасность на уровне БД
- Легко добавлять новые статусы
- Валидация на уровне схемы БД
- Константы в коде для удобства использования

**Реализация**: 
- Enum в миграции: `enum('status', ['new', 'assigned', 'in_progress', 'done', 'canceled'])`
- Константы класса: `Request::STATUS_NEW`, `Request::STATUS_ASSIGNED` и т.д.

## 5. Роли пользователей: dispatcher и master

**Решение**: Две роли пользователей с разными правами доступа.

**Обоснование**:
- Простота реализации (соответствует ТЗ)
- Чёткое разделение ответственности
- Легко расширять новыми ролями при необходимости

**Реализация**:
- Enum в БД: `enum('role', ['dispatcher', 'master'])`
- Методы проверки: `User::isDispatcher()`, `User::isMaster()`
- Middleware в контроллерах для проверки роли

## 6. Использование Docker Compose для развёртывания

**Решение**: Приложение поставляется с Docker Compose конфигурацией.

**Обоснование**:
- Быстрый запуск без настройки окружения
- Изоляция зависимостей
- Единообразие окружения для всех разработчиков
- Простота деплоя

**Реализация**: 
- Отдельные контейнеры для app, nginx, mysql, redis
- Порты смещены (8080, 3307, 6380) для избежания конфликтов
- Volumes для персистентности данных

## 7. Blade шаблоны вместо SPA

**Решение**: Использованы Blade шаблоны для рендеринга на сервере.

**Обоснование**:
- Простота реализации для небольшого приложения
- Меньше сложности (не нужен отдельный фронтенд)
- SEO-friendly (если потребуется)
- Быстрая разработка

**Альтернативы**: 
- SPA (React/Vue) - избыточно для данного функционала
- API + отдельный фронтенд - усложняет архитектуру
